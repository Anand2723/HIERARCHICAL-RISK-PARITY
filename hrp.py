# -*- coding: utf-8 -*-
"""HRP

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ddyqo0jTRi-EtiYUTg-Yw3af7X9uo-wL
"""

!pip install yfinance

import pandas as pd
import numpy as np
from scipy.cluster.hierarchy import dendrogram, linkage
from matplotlib import pyplot as plt
import seaborn as sns
import yfinance as yf

stocks = ['ORCL','EL','NOW','ADI','ISRG','CVS','T','EOG','REGN','TJX']
stocks_compl = ["AAPL"] + stocks

apl = yf.Ticker("AAPL")
aapl = apl.history(period ='5y')

pct_aapl = aapl["Close"].pct_change()

prices_aapl = aapl["Close"]
returns = pct_aapl.to_frame()
prices = prices_aapl.to_frame()

returns = returns.rename(columns={"Close": stocks_compl[0]})
prices = prices.rename(columns={"Close": stocks_compl[0]})

for stock in stocks:
    df1 = yf.Ticker(stock)
    df = df1.history(period='5y')
    df_pct = df["Close"].pct_change()
    df_price = df["Close"]
    returns = returns.join(df_pct).rename(columns={"Close": stock})
    prices = prices.join(df_price).rename(columns={"Close": stock})

returns = returns.dropna()

corr = returns.corr()

ax = sns.heatmap(corr, cmap="coolwarm")

d_corr = np.sqrt(0.5*(1-corr))

link = linkage(d_corr, 'single')
Z = pd.DataFrame(link)

fig = plt.figure(figsize=(25, 10))
dn = dendrogram(Z, labels = stocks_compl)
plt.show()

def get_quasi_diag(link):
    link = link.astype(int)
    # get the first and the second item of the last tuple
    sort_ix = pd.Series([link[-1,0], link[-1,1]])
    # the total num of items is the third item of the last list
    num_items = link[-1, 3]
    # if the max of sort_ix is bigger than or equal to the max_items
    while sort_ix.max() >= num_items:
        sort_ix.index = range(0, sort_ix.shape[0]*2, 2)
        df0 = sort_ix[sort_ix >= num_items] 
        i = df0.index
        j = df0.values - num_items
        sort_ix[i] = link[j,0] # item 1
        df0 = pd.Series(link[j, 1], index=i+1)
        sort_ix = pd.concat([sort_ix,df0])
        sort_ix = sort_ix.sort_index()
        sort_ix.index = range(sort_ix.shape[0])
    return sort_ix.tolist()

sort_ix = get_quasi_diag(link)
stocks_compl = np.array(stocks_compl)
df_vis = returns[stocks_compl[sort_ix]]
corr2 = df_vis.corr()
ax = sns.heatmap(corr2, cmap="coolwarm")

def get_cluster_var(cov, c_items):
    cov_ = cov.iloc[c_items, c_items] # matrix slice
    # calculate the inversev-variance portfolio
    ivp = 1./np.diag(cov_)
    ivp/=ivp.sum()
    w_ = ivp.reshape(-1,1)
    c_var = np.dot(np.dot(w_.T, cov_), w_)[0,0]
    return c_var

def get_rec_bipart(cov, sort_ix):
    # compute HRP allocation
    # intialize weights of 1
    w = pd.Series(1, index=sort_ix)
    # intialize all items in one cluster
    c_items = [sort_ix]
    while len(c_items) > 0:
        c_items = [i[int(j):int(k)] for i in c_items for j,k in
        ((0,len(i)/2),(len(i)/2,len(i))) if len(i)>1]
        # now it has 2
        for i in range(0, len(c_items), 2):
            c_items0 = c_items[i] # cluster 1
            c_items1 = c_items[i+1] # cluter 2
            c_var0 = get_cluster_var(cov, c_items0)
            c_var1 = get_cluster_var(cov, c_items1)
            alpha = 1 - c_var0/(c_var0+c_var1)
            w[c_items0] *= alpha
            w[c_items1] *=1-alpha
    return w

def compute_MV_weights(covariances):
    inv_covar = np.linalg.inv(covariances)
    u = np.ones(len(covariances))
    x = np.dot(inv_covar, u) / np.dot(u, np.dot(inv_covar, u))
    return pd.Series(x, index = stocks_compl, name="MV")

def compute_RP_weights(covariances):
    weights = (1 / np.diag(covariances))
    x = weights / sum(weights)
    return pd.Series(x, index = stocks_compl, name="RP")

def compute_unif_weights(covariances):
    x = [1 / len(covariances) for i in range(len(covariances))]
    return pd.Series(x, index = stocks_compl, name="unif")

cov = returns.cov()

weights_HRP = get_rec_bipart(cov, sort_ix)
new_index = [returns.columns[i] for i in weights_HRP.index]
weights_HRP.index = new_index
weights_HRP.name = "HRP"

weights_MV = compute_MV_weights(cov)
weights_RP = compute_RP_weights(cov)
weights_unif = compute_unif_weights(cov)

results = weights_HRP.to_frame()
results = results.join(weights_MV.to_frame())
results = results.join(weights_RP.to_frame())
results = results.join(weights_unif.to_frame())
print(results)

def compute_ER(weights):
    mean = returns.mean(0)
    return weights.values * mean

er_hrp = compute_ER(weights_HRP)
er_hrp.name = "HRP"
er_mv = compute_ER(weights_MV)
er_mv.name = "MV"
er_rp = compute_ER(weights_RP)
er_rp.name = "RP"
er_unif = compute_ER(weights_unif)
er_unif.name = "unif"

ers = er_hrp.to_frame()
ers = pd.concat([ers,er_mv.to_frame()])
ers = pd.concat([ers,er_rp.to_frame()])
ers = pd.concat([ers,er_unif.to_frame()])
ers = ers.sum()
ers.name = "Expected Return"
ers = ers.to_frame()
print(ers)

def portfolio_volatility(weights, cov):
    return np.sqrt(np.dot(np.dot(weights.values, cov.values), weights.values))

data = [portfolio_volatility(weights_HRP, cov)]
data.append(portfolio_volatility(weights_MV, cov))
data.append(portfolio_volatility(weights_RP, cov))
data.append(portfolio_volatility(weights_unif, cov))
volatility = pd.DataFrame(data = data, index=["HRP", "MV", "RP", "unif"],
columns=["Volatility"])

def risk_free():
    return 0

def sharpe_ratio(weights, cov):
    ret_portfolio = compute_ER(weights).sum()
    ret_free = risk_free()
    volatility = portfolio_volatility(weights, cov)
    return (ret_portfolio - ret_free)/volatility

data = [sharpe_ratio(weights_HRP, cov)]
data.append(sharpe_ratio(weights_MV, cov))
data.append(sharpe_ratio(weights_RP, cov))
data.append(sharpe_ratio(weights_unif, cov))
sharpe_R= pd.DataFrame(data = data, index=["HRP", "MV", "RP", "unif"],
columns=["Sharpe Ratio"])
print(sharpe_R)

def compute_mdd(weights):
    df = weights * prices
    df = df.sum(1)
    roll_max = df.cummax()
    daily_drawdown = df/roll_max - 1.0

data = [compute_mdd(weights_HRP)]
data.append(compute_mdd(weights_MV))
data.append(compute_mdd(weights_RP))
data.append(compute_mdd(weights_unif))
dd = pd.DataFrame(data = data, index=["HRP", "MV", "RP", "unif"],
columns = ["Max DD"])

def diversification_ratio(weights, cov):
    p_volatility = portfolio_volatility(weights, cov)
    return np.dot(np.sqrt(np.diag(cov.values)), weights) / p_volatility

data = [diversification_ratio(weights_HRP, cov)]
data.append(diversification_ratio(weights_MV, cov))
data.append(diversification_ratio(weights_RP, cov))
data.append(diversification_ratio(weights_unif, cov))
dr = pd.DataFrame(data = data, index=["HRP", "MV", "RP", "unif"],
columns = ["Div Ratio"])

final_results = ers.join(volatility)
final_results = final_results.join(sharpe_R)
final_results = final_results.join(dd)
final_results = final_results.join(dr)
print(final_results)